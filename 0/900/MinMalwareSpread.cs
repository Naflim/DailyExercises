using Naflim.DevelopmentKit.DataStructure.Graph;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DailyExercises
{
    /// <summary>
    /// 928. 尽量减少恶意软件的传播 II
    /// </summary>
    internal class MinMalwareSpread
    {
        public static int Run(int[][] graph, int[] initial)
        {
            List<Graph<int>> graphs = new List<Graph<int>>();
            int n = graph.Length;
            HashSet<int> initialHash = new HashSet<int>(initial);

            Func<int, IEnumerable<int>> func = v =>
            {
                List<int> list = new List<int>();

                for (int i = 0; i < n; i++)
                {
                    if (graph[v][i] == 1 && i!=v)
                        list.Add(i);
                }

                return list;
            };


            for (int i = 0; i < n; i++)
            {
                if (!graphs.Any(g => g.Contains(i)))
                {
                    graphs.Add(new Graph<int>(i, func));
                }
            }

            int minIndex = int.MaxValue;
            int minCount = int.MaxValue;

            foreach (var cutVertex in initial)
            {
                int count = 0;
                List<Graph<int>> gs = new List<Graph<int>>();

                foreach (var g in graphs)
                {
                    if (g.Contains(cutVertex))
                    {
                        gs.AddRange(g.Copy().Split(cutVertex));
                    }
                    else
                    {
                        gs.Add(g);
                    }
                }

                foreach (var g in gs)
                {
                    if (initialHash.Overlaps(g))
                    {
                        count += g.Count;
                    }
                }

                if (count < minCount)
                {
                    minCount = count;
                    minIndex = cutVertex;
                }
                else if (count == minCount)
                {
                    minIndex = Math.Min(cutVertex, minIndex);
                }
            }

            return minIndex;
        }
    }
}
